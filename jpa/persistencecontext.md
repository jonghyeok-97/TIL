#### 변경 감지 작동 원리
JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 스냅샷을 저장한다.
1. 트랜잭션 커밋 -> 엔티티 매니저 내부에서 플러시 호출
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티 찾음
3. 변경된 엔티티가 있으면 수정 쿼리를 작성해서 쓰기 지연을 위해 SQL저장소로 보냄.
4. 쓰기 지연을 위한 SQL저장소의 쿼리를 DB에 전송.
5. 트랜잭션을 커밋

#### 쓰기 지연 동작 원리는?
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이것을 쓰기지연이라 한다.

#### 동일성을 어떻게 보장하는지?
- 식별자를 가지고, 동일성을 보장하며, 식별자가 있어야만 영속성 컨텍스트에서 관리된다.

#### 지연 로딩시 하위 엔티티가 프록시 객체로 온다. 이 때, 프록시 객체의 @Id 값이 영속성 컨텍스트에 있는지?
    - 있다.
    - 프록시 객체는 영속성컨텍스트의 도움을 받아야만 초기화 될 수 있다. → OSIV 설정을 off하면, Lazy Loading 관련 Exception 발생
    - 프록시 객체가 초기화 된다는 것은 프록시 객체가 실제 객체를 참조할 수 있게 되는 것이지, 실제 객체로 바뀌지 않는다!
    - 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다.