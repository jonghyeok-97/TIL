### 분할 정복법.md
- 분할: 해결하고자 하는 문제를 작은 크기의 동일한 문제로 분할
- 정복: 각각의 작은 문제를 순환적으로 해결
- 합병: 작은 문제의 해를 합하여 원래 문제에 대한 해를 구함

#### merge sort (합병 정렬)
- 분할 & 정복
  - 분할하고 정복하는 과정에서 영역을 절반씩 recursion(재귀) 적으로 분할 한다.
  - 더 이상 분할할 영역이 없을 때까지 recursion(재귀)적으로 분할 한다.
- 합병
  - 합병하는 과정에서 추가 배열을 사용하여, 정렬한다.
  - 그래서, 합병의 대상이 되는 두 영역이 각 영역에 대해서 정렬이 되어 있기 때문에 합병 할 때, 두 영역을 비교하면서 정렬을 할 수가 있다.
  - 합병정렬은 순차적인 비교로 정렬을 진행하므로 LinkedList 정렬에 효과적이다.

- 최선/최악/평균 시간복잡도 : O(n logn)

#### quick sort (빠른 정렬)
- 분할 & 정복
  - 분할할 때, 합병 정렬처럼 영역을 절반이 아닌 피벗를 기준으로 나누면서 진행
    - 임의의 요소를 pivot 이라 하며, 이 피벗은 처음, 끝, 중간, 랜덤 요소가 될 수 있음
  - 그래서, 영역을 피벗을 기준으로 분할을 하게 되어 피벗보다 작은 영역과 피벗보다 큰 영역으로 나뉘게 됨.
    - 이 과정을 partition 이라 하며, 한 번의 partition 의 시간복잡도는 O(n)
  - 각 부분을 순환적으로 정렬한다.
- 합병
  - 분할 & 정복을 하며 피벗을 기준으로 정렬을 했기 때문에 할 것이 없다.

- 최악의 시간 복잡도: O(n2)
  - 이미 정렬된 입력 데이터에서 마지막 원소(최대값 or 최소값)를 피벗으로 선택해서 파티션이 나눠지지 않았을 경우
  - 항상 한쪽은 0개, 다른 쪽은 n - 1 개롭 분할될 때.
- 최선/평균의 시간 복잡도: O(n log n) 
  - 항상 절반으로 분할되는 경우 (피벗이 항상 정 가운데인 값인 경우)
  - 다른 O(n logn) 을 가진 정렬보다 더 빠르다. 왜 Quick sort 가 더 빠른가?
    - 퀵 소트는 새로운 배열을 만들지 않고 기존 배열만을 가지고 정렬하기 때문에 캐시 친화적인 반면 merge sort 는 새로운 배열을 만들어서 캐시친화적이지 않다.
  - 최악의 시간 복잡도가 O(n2) 이지만 Quick sort 를 사용하는 이유?
    - 파티션될 때, 두 영역이 1:9로만 나뉘어 져도 시간 복잡도는 O(n logn)이다.
  - 피벗을 어떻게 선택하더라도 입력이 정렬되고, 피벗의 최소/최대 값으로 들어올 경우가 있으므로 최악의 시간복잡도는 바뀌지 않는다.