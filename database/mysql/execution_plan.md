#### 실행계획 소개
실행계획 포맷 표시 → `EXPLAIN FORMAT=TREE` `EXPLAIN FORMAT=JSON`  `EXPLAIN FORMAT=TABLE`
TREE 포맷의 실행 순서는 다음 기준으로 읽는다.
- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행.

actual time ( 실제 소요된 시간)
- actual time=0.007..0.009 → 0.007은 첫 번째 레코드를 가져오는데 걸린 평균 시간, 0.009 는 마지막 레코드를 가져오는데 걸린 평균 시간

rows ( 처리한 레코드 건수)
- rows=10 → 테이블의 평균 레코드 건수

loops (반복 횟수)
- 테이블의 레코드를 찾는 작업이 반복된 횟수. s.emp_no = e.emp_no 쿼리에서 emp_no 에 해당하는 s.emp_no 를 찾는데, loops 가 233이라면 emp_no 의 갯수가 233이란 것이다.

actual time 과 rows 설명에서 평균 시간과 평균 레코드라 했는데, 이는 loops 필드의 값이 1 이상이기 때문이다. 즉 salaries 테이블에서 emp_no 일치 건을 찾는 작업을 233번 반복해서 실행했는데, 매번 salaries 테이블에서 첫 번쨰 레코드를 가져오는데 평균 0.007밀리초가 걸렸으며, 마지막 레코드를 읽는 데는 평균 0.009밀리초가 걸린 것이다.

#### 실행계획 분석
**id**
- 실행계획의 id 칼럼이 테이블의 접근 순서를 의미하지 않는다. → explain analyze 를 통해 접근 순서를 확인해야 한다.
- id 는 SELECT 쿼리별로 부여되는 식별자 값이다.

**select_type**
- 각 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼.
- SIMPLE
    - UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리(JOIN포함)
- PRIMARY
    - UNION 이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 SELECT
- UNION
    - UNION 으로 결합하는 SELECT 중, 첫 번째를 제외한 두 번쨰 이후 SELECT 쿼리
    - UNION 으로 결합하는 첫 번째 쿼리는 DERIVED(UNION 결과를 모은 임시 테이블)로 표시된다.
- SUBQUERY
    - FROM절을 제외한 다른 절에서 실행된 SELECT 쿼리
    - FROM 절에서 실행된 SELECT 쿼리는 DERIVED 로 표시된다.
- DERIVED
    - SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.

쿼리를 튜닝하기 위해 실행 계획에 select_type 이 DERIVED 인 것이 있는지 확인하며, 서브 쿼리를 조인으로 해결하려고 강력히 권장한다.

**table**
- 어떤 테이블을 사용했는지 표시
- <> 로 둘러싸여 표시되면, 이 테이블은 임시 테이블을 의미한다. 그리고, <>안의 있는 숫자는 SELECT 쿼리의 id값을 지칭한다.
- ex) <derived2> 라면, id가 2고, select_type 이 derived 에 의해 생성된 임시 테이블을 의미한다.

**partitions**
- 어떤 파티션을 사용했는지 알려준다.

**type**
- type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽엇는지 나타낸다. 반드시 체크해야 하는 칼럼이다.
- 12개의 접근 방법 중, ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다. ALL은 풀테이블 스캔을 의미한다.
- 성능이 빠른 순서로 접근 방법 나열
- system → const → eq_ref → ref → fulltext → ref_or_null → unique_subquery → index_subquery → range → index_merge → index → ALL
  - **system**
  - 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다. 단, InnoDB 스토리지 엔진에서는 사용되지 않고, MyISAM 이나 MEMORY 스토리지 엔진에서 사용된다.
  - **const**
  - 테이블의 레코드 건수와 상관없이 쿼리가 PK나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리를 의미(다른 DBMS 는 유니크 인덱스 스캔)이라 함.
  - 단, PK의 일부만 WHERE 조건에 사용할 때는 실제 1건의 레코드만 있더라도 ref 로 표시된다.
  - **eq_ref**
  - 조인되는 쿼리의 실행 계획에서만 표시됨.
  - 조인에서 처음 읽은 테이블의 칼럼값을, 그 다음 읽어야 할 테이블의 PK나 유니크 키 칼럼의 검색 조건에 사용할 때 나온다.
  - 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용 가능.
  - **ref**
  - 조인의 순서와 관계없이 사용, PK나 유니크 제약 조건도 없다. 동등 조건으로 검색될 때 사용. → 빠르다.
  정리 (Good)
  - const : 조인의 순서와 관계없이 PK나 유니크의 모든 칼럼에 대해 동등 조건으로 검색하며 반드시 1건의 레코드만 반환
  - eq_ref : 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 PK나 유니크 키로 동등 조건 검색(두 번쨰 테이블은 반드시 1건의 레코드만 반환)
  - ref : 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색(1건의 레코드만 반환되지 않음)
  ---
  이후로는, type 의 순서가 일반적인 처리 성능의 순서이지만, 데이터의 분포나 레코드의 건수에 따라 빠른 순서를 달라질 수 있따.
  - **fulltext**
  - 전문 검색 인덱스를 사용해 레코드 읽을 때 사용됨.
  - 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const / eq_ref / ref 강 아니면 MySQL은 전문 인덱스를 사용한다.
  - 필자 경험상, range 접근이 더 빨리 처리되는 경우가 많아서, 조건별로 성능을 확인을 하자.
  - **ref_or_null**
  - ref + null 비교 인 형태로, 많이 활용되진 않지만 나쁘지 않다.
  - **unique_subquery**
  - WHERE 조건 절에서 사용될 수 있는 IN 형태의 서브 쿼리를 위한 방법이다.
  - 서브쿼리에서 중복되지 않은 유니크한 값만 반환할 때, 사용,
  - **index_subquery**
  - 만약, IN절 안에서 중복된 값이 있을 수 있지만, 인덱스를 이용해 중복된 값을 제거할 수 있을 때, 사용됨.
  - **range**
  - 인덱스를 하나의 값이 아니라 범위로 검색하는 경우, < > IS NULL, BETWEEN, IN, LIKE 연산자를 이용해 인덱스를 검색할 떄 사용.
  - const, ref, range 는 인덱스 레인지 스캔으로 묶어서 지칭한다. 인덱스를 효율적으로 사용, 작업 범위 결정 조건으로 인덱스를 사용한다를 표현이다.
  - **index_merge**
  - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만든 후 그 결과를 병합해서 처리.
  - **index**
  - 인덱스 풀 스캔이다.
  - 다음 조건 중, (첫 번쨰 + 두 번째)조건을 충족하거나 (첫 번쨰 + 세번쨰)조건을 충족하는 쿼리에서 사용된다.
  - range 나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
  - 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우(데이터 파일 안읽어도 될 경우)
  - 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우
  - 이 경우, LIMIT 이 있다면 효율적이다.
  - **ALL**
  - 풀 테이블 스캔.