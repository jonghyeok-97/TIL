#### 실행계획 소개
실행계획 포맷 표시 → `EXPLAIN FORMAT=TREE` `EXPLAIN FORMAT=JSON`  `EXPLAIN FORMAT=TABLE`
TREE 포맷의 실행 순서는 다음 기준으로 읽는다.
- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행.

actual time ( 실제 소요된 시간)
- actual time=0.007..0.009 → 0.007은 첫 번째 레코드를 가져오는데 걸린 평균 시간, 0.009 는 마지막 레코드를 가져오는데 걸린 평균 시간

rows ( 처리한 레코드 건수)
- rows=10 → 테이블의 평균 레코드 건수

loops (반복 횟수)
- 테이블의 레코드를 찾는 작업이 반복된 횟수. s.emp_no = e.emp_no 쿼리에서 emp_no 에 해당하는 s.emp_no 를 찾는데, loops 가 233이라면 emp_no 의 갯수가 233이란 것이다.

actual time 과 rows 설명에서 평균 시간과 평균 레코드라 했는데, 이는 loops 필드의 값이 1 이상이기 때문이다. 즉 salaries 테이블에서 emp_no 일치 건을 찾는 작업을 233번 반복해서 실행했는데, 매번 salaries 테이블에서 첫 번쨰 레코드를 가져오는데 평균 0.007밀리초가 걸렸으며, 마지막 레코드를 읽는 데는 평균 0.009밀리초가 걸린 것이다.

#### 실행계획 분석
**id**
- 실행계획의 id 칼럼이 테이블의 접근 순서를 의미하지 않는다. → explain analyze 를 통해 접근 순서를 확인해야 한다.
- id 는 SELECT 쿼리별로 부여되는 식별자 값이다.

**select_type**
- 각 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼.
- SIMPLE
    - UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리(JOIN포함)
- PRIMARY
    - UNION 이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 SELECT
- UNION
    - UNION 으로 결합하는 SELECT 중, 첫 번째를 제외한 두 번쨰 이후 SELECT 쿼리
    - UNION 으로 결합하는 첫 번째 쿼리는 DERIVED(UNION 결과를 모은 임시 테이블)로 표시된다.
- SUBQUERY
    - FROM절을 제외한 다른 절에서 실행된 SELECT 쿼리
    - FROM 절에서 실행된 SELECT 쿼리는 DERIVED 로 표시된다.
- DERIVED
    - SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.

쿼리를 튜닝하기 위해 실행 계획에 select_type 이 DERIVED 인 것이 있는지 확인하며, 서브 쿼리를 조인으로 해결하려고 강력히 권장한다.

**table**
- 어떤 테이블을 사용했는지 표시
- <> 로 둘러싸여 표시되면, 이 테이블은 임시 테이블을 의미한다. 그리고, <>안의 있는 숫자는 SELECT 쿼리의 id값을 지칭한다.
- ex) <derived2> 라면, id가 2고, select_type 이 derived 에 의해 생성된 임시 테이블을 의미한다.

**partitions**
- 어떤 파티션을 사용했는지 알려준다.

**type**
- type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽엇는지 나타낸다. 반드시 체크해야 하는 칼럼이다.
- 12개의 접근 방법 중, ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다. ALL은 풀테이블 스캔을 의미한다.
- 성능이 빠른 순서로 접근 방법 나열
- system → const → eq_ref → ref → fulltext → ref_or_null → unique_subquery → index_subquery → range → index_merge → index → ALL
  - **system**
  - 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다. 단, InnoDB 스토리지 엔진에서는 사용되지 않고, MyISAM 이나 MEMORY 스토리지 엔진에서 사용된다.
  - **const**
  - 테이블의 레코드 건수와 상관없이 쿼리가 PK나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리를 의미(다른 DBMS 는 유니크 인덱스 스캔)이라 함.
  - 단, PK의 일부만 WHERE 조건에 사용할 때는 실제 1건의 레코드만 있더라도 ref 로 표시된다.
  - **eq_ref**
  - 조인되는 쿼리의 실행 계획에서만 표시됨.
  - 조인에서 처음 읽은 테이블의 칼럼값을, 그 다음 읽어야 할 테이블의 PK나 유니크 키 칼럼의 검색 조건에 사용할 때 나온다.
  - 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용 가능.
  - **ref**
  - 조인의 순서와 관계없이 사용, PK나 유니크 제약 조건도 없다. 동등 조건으로 검색될 때 사용. → 빠르다.
  정리 (Good)
  - const : 조인의 순서와 관계없이 PK나 유니크의 모든 칼럼에 대해 동등 조건으로 검색하며 반드시 1건의 레코드만 반환
  - eq_ref : 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 PK나 유니크 키로 동등 조건 검색(두 번쨰 테이블은 반드시 1건의 레코드만 반환)
  - ref : 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색(1건의 레코드만 반환되지 않음)
  ---
  이후로는, type 의 순서가 일반적인 처리 성능의 순서이지만, 데이터의 분포나 레코드의 건수에 따라 빠른 순서를 달라질 수 있따.
  - **fulltext**
  - 전문 검색 인덱스를 사용해 레코드 읽을 때 사용됨.
  - 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const / eq_ref / ref 강 아니면 MySQL은 전문 인덱스를 사용한다.
  - 필자 경험상, range 접근이 더 빨리 처리되는 경우가 많아서, 조건별로 성능을 확인을 하자.
  - **ref_or_null**
  - ref + null 비교 인 형태로, 많이 활용되진 않지만 나쁘지 않다.
  - **unique_subquery**
  - WHERE 조건 절에서 사용될 수 있는 IN 형태의 서브 쿼리를 위한 방법이다.
  - 서브쿼리에서 중복되지 않은 유니크한 값만 반환할 때, 사용,
  - **index_subquery**
  - 만약, IN절 안에서 중복된 값이 있을 수 있지만, 인덱스를 이용해 중복된 값을 제거할 수 있을 때, 사용됨.
  - **range**
  - 인덱스를 하나의 값이 아니라 범위로 검색하는 경우, < > IS NULL, BETWEEN, IN, LIKE 연산자를 이용해 인덱스를 검색할 떄 사용.
  - const, ref, range 는 인덱스 레인지 스캔으로 묶어서 지칭한다. 인덱스를 효율적으로 사용, 작업 범위 결정 조건으로 인덱스를 사용한다를 표현이다.
  - **index_merge**
  - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만든 후 그 결과를 병합해서 처리.
  - **index**
  - 인덱스 풀 스캔이다.
  - 다음 조건 중, (첫 번쨰 + 두 번째)조건을 충족하거나 (첫 번쨰 + 세번쨰)조건을 충족하는 쿼리에서 사용된다.
  - range 나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
  - 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우(데이터 파일 안읽어도 될 경우)
  - 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우
  - 이 경우, LIMIT 이 있다면 효율적이다.
  - **ALL**
  - 풀 테이블 스캔.

- **key**
- possible_key 는 무시
- 해당 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용한 인덱스이다.
- 그래서, 쿼리 튜닝 시 key 칼럼에 의도했떤 인덱스가 표시되는지 확인하는 것이 중요하다.
- **key_len**
- 단일 컬럼 인덱스보다 멀티 컬럼 인덱스가 실무에서 더 자주쓰이는데, 멀티 컬럼 인덱스에서 매우 중요하다.
key_len 은 쿼리를 처리하기 위해 멀티 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다. 더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.
utf8mb4 에서 무조건 4바이트로 계산, NULLABEL 한 컬럼에는 1바이트가 추가된다 만약, DATE 는 3바이트인데 4가 나왔다? DATE컬럼이 NULLABLE 이라서,

- **ref**
  - 무시해도 좋다. 단, func 은 MySQL이 내부적으로 칼럼의 값을 바꿔서 처리했다는 얘기임.

**extra**

  쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 컬럼에 자주 표시된다. 만약, 이 곳에 없는 문장이 뜬다면, 공식문서를 참고하자.

  - **const row not found**

    const접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않을 때, 나온다.

  - **Distinct**

    쿼리의 DISTINCT 를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시해서 꼭 필요한 레코드만 읽었다는 것임.

  - **FirstMatch**

    FirstMatch 메시지에 함께 표시되는 테이블명은 기준 테이블을 의미, 세미 조인(서브 쿼리의 IN과 EXIST)에서 불필요한 추가 탐색을 줄이기 위해, 조건을 만족하는 첫 번째 결과만 확인하고 즉시 종료하는 최적화 전략입니다.

  - **Full scan on NULL key**

    IN 이나 NOT IN 연산자의 왼쪽 값이 NULL 일 때, 오른쪽의 쿼리에서 풀테이블 스캔을 하는 경우다.

  - **Impossible HAVING**

    쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 표시. → 쿼리가 제대로 작성되지 못한 경우가 대부분이라, 쿼리를 다시 점검하자.

  - **Impossible WHERE**

    WHERE 조건이 항상 false 가 될 경우, 표시

  - **No matching min/max row**

    MIN(), MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때, 표시

  - **Not Exists**

    A 테이블에는 존재하지만, B테이블에는 없는 값을 조회해야 하는 쿼리가 자주 사용되는데, 이 때 주로 NOT IN(subquery) 형태나 NOT EXISTS 연산자를 주로 사용하는 안티-조인이라 한다.

    **안티조인과 세미조인의 차이**

    | 조인 유형 | 설명 | 반환 데이터 |
            | --- | --- | --- |
    | **세미조인** | 주 테이블의 행이 서브 테이블과 **일치** | 주 테이블의 일치하는 행만 |
    | **안티조인** | 주 테이블의 행이 서브 테이블과 **불일치** | 주 테이블의 불일치 행만 |

    이 때, 레코드 건수가 많으면 아우터 조인을 이용하는 게 좋다.

    아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서 주로 표시된다.

  - **Using filesort**

    ORDER BY 처리가 인덱스를 사용하지 못할 때 표시, ORDER BY가 사용된 쿼리의 실행 계획에서만 나타난다.

    MySQL 옵티마이저는 레코드를 읽어서 소트 버퍼에 복사하고, 정렬해서 그 결과를 클라이언트에 보낸다.

    실행 계획의 Using filesort 가 출력되는 쿼리는 많은 부하를 일으키므로 가능하면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.

    조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 또는 힙 소트를 이용해 정렬을 수행하게 됨. → 쿼리를 튜닝하거나, 인덱스 생성하자.

  - Using index (커버링 인덱스)
  - Using index condition → 인덱스 컨디션 푸시 다운? 9.3.1.3절 참조
  - Using index for group-by (10.3.12.24)
  - Using index for skip scan(10.3.12.25)
  - Using join buffer (10.3.12.26)
  - Using MRR (10.3.12.27)
  - Using sort_union, Using intersect (10.3.12.28)
  - **Using temporary**
    - MySQL 서버에서 쿼리를 처리하는 동안 중간 결과를 담기 위해 임시 테이블을 사용한다. 임시 테이블은 메모리상에 생성될 수도, 디스크상에 생성될 수도 있다.
    - 해당 키워드가 표시되면, 임시 테이블을 사용한 것인데, 실행 계획만으로는 메모리인지 디스크인지 판단할 수 없다.
      - 알려면 SHOW STATUS LIKE ‘Created_tmp%’; 를 하자.
    - 그러나, 이 키워드가 표시되지 않았지만, 실제 임시 테이블을 사용할 때도 많다. 대표적으로 임시 테이블을 생성하는 쿼리는 다음과 같다.
      - FROM 절에 사용된 서브쿼리는 무조건 임시 테이블을 생성
      - Count (DISTINCT 칼럼)를 포함하는 쿼리도 인덱스를 사용할 수 없는 경우 만든다.
      - UNION / UNION DISTINCT 가 사용된 쿼리.
      - 인덱스를 사용하지 못하는 정렬 작업은 임시 버퍼 공간을 사용하는데 이 버퍼의 실체는 임시 테이블과 같다. 이 때는, Using filesort 라 표시된다.
      - MySQL이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑 할 때는 내부적인 임시 테이블을 사용한다. (CREATE TEMPORARY TABLE명령으로 만든 임시 테이블과 다르다.)
        - 이 임시 테이블은 다른 세션이나 쿼리에서 볼 수 없으며 사용도 불가하다.
        - 쿼리의 처리가 완료되면 자동으로 삭제된다.
      - 임시 테이블에 대해 블로그에 쓸 때는 9.2.6.3 을 참조하자.
  - **Using where**
    - 각 스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할,
    - MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산한다.(조인, 필터링, 집합처리…)
    - 스토리지 엔진은 작업 범위 결정 조건이지만, MySQL 엔진은 체크 조건(필터링)이다.
    - MySQL엔진에서 필터링 작업을 처리한 경우, Using where 이 표시된다. 이 Using where 이 성능상 좋은지 확인하는 것은 filtered 칼럼을 같이 보는 것이다. filtered 가 50%면 MySQL엔진이 스토리지 엔진으로 부터 읽은 행 중, 절반을 체크 조건으로 필터링 한것이기 때문에 스토리지 엔진은 불 필요하게 읽은 레코드가 절반이나 된다.

  - **Zero limit**

    사용자가 쿼리 결과의 메타데이터 정보(결과의 칼럼 타입들은 무엇이 있는지 등)를 확인하기 위해 LIMIT 0 을 사용하는데, 이 때 옵티마이저는 사용자의 의도를 알아채고, 레코드를 읽지 않으면서 표시되는 내용이다.