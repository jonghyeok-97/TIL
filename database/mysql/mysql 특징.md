#### MVCC(Multi Version Concurrency Control)

목적
- 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. 언두 로그를 이용해 이 기능을 구현한다.
- 멀티 버전은 하나의 레코드에 여러 개의 버전이 동시에 관리된다는 의미

멀티 버전에서 다른 트랜잭션이 한 트랜잭션에서 변경되는 행을 읽을 때
- 격리 수준이 READ_UNCOMMITTTED 경우, InnoDB버퍼 풀이나 데이터 파일로부터 변경되지 않는 데이터를 읽어서 반환. 즉, 데이터가 커밋됐든 아니든 변경된 상태의 데이터를 반환.
- READ_COMMITTED 이상인 경우, 변경되지 이전의 내용을 보관하는 언두 영역의 데이터를 반환한다.
- 언두 영역이 삭제되는 시기는 해당 영역을 필요로 하는 트랜잭션이 없을 때 이다.

#### MySQL 8.0 락 종류
- 레코드 락
    - 레코드 자체만을 잠근다. InnoDB는 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것이 다른 DBMS와 다르다. 인덱스가 하나도 없더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
    - 이외의 락은 넥스트 키 락과 갭 락을 사용하지만, PK와 유니크 인덱스에 의한 변경 작업에서 갭에 대해서는 잠그지 않고 레코드 자체에만 락을 건다.
- 갭 락
    - 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
    - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다.
    - 넥스트 키 락의 일부로 주로 사용된다.
- 넥스트 키 락
    - 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장하는 것이 주 목적이다.
    - 데드락이 자주 발생하면, 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

#### UPDATE / DELETE 시, WHERE 조건의 중요성
또한, MySQL은 UPDATE나 DELETE 작업 시 내부적으로 자동으로 락을 설정하기 위해 WHERE 조건이 중요합니다.
WHERE 조건에 사용되는 컬럼에 적절한 인덱스가 없는 경우, 쓰기 작업을 할 레코드뿐만 아니라 다른 레코드에도 락이 걸릴 수 있고, 최악의 경우 테이블 단위로 락이 걸릴 수 있습니다. 즉, UPDATE / DELETE 작업을 할 때, WHERE 조건에 PK와 같은 인덱스가 있는 컬럼을 사용해야 한다는 의미입니다.
WHERE 조건에 인덱스가 없는 UPDATE / DELETE 쿼리가 실행되면 테이블의 모든 행을 스캔하게 되어 불필요한 레코드에도 락이 설정될 수 있습니다. 이를 방지하기 위해 UPDATE나 DELETE 시 WHERE 조건에 PK든 세컨더리 인덱스가 있는 컬럼을 설정함으로써 불필요한 레코드에 락이 걸리는 것을 방지하는 것이 중요합니다.

#### 체인지 버퍼
체인지 버퍼는 레코드에 쓰기 작업이 발생할 경우, 해당 레코드의 세컨더리 인덱스를 업데이트 하는 작업도 필요하다. 이 세컨더리 인덱스를 업데이트 하는 건 랜덤 Disk I/O가 발생하며, 이는 시간이 오래 걸리는 작업이다.
만약, 업데이트 할 인덱스 페이지가 버퍼 풀에 있으면 바로 인덱스 페이지를 업데이트 하지만, 디스크로부터 읽어와서 업데이트 해야한다면 이를 임시 메모리 공간인 체인지 버퍼에 저장하고, 이곳으로부터 결과를 반환한다.
이를 해결하기 위해 체인지 버퍼라를 메모리 공간에 캐싱한다.
체인지 버퍼는 InnoDB 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정돼있으며, 필요하다면 50% 까지 사용하게 설정 할 수 있다.
체인지 버퍼의 인덱스 페이지가 디스크에 반영되는 시점은 백그라운드 스레드가 주기적으로 병합한다.